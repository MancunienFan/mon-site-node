"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
const misc_1 = require("./misc");
const api_1 = require("../../lib/api");
const SSO_1 = require("./SSO");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('node-expose-sspi:connect');
/**
 * Retrieves SSO information from an explicit credential (login/password and domain).
 * The SSO information will be retrieved only if the credential
 * matches a local account or a domain account.
 *
 * @param {sspi.UserCredential} userCredential
 * @returns {SSO} the SSO object.
 */
async function connect(userCredential) {
    const errorMsg = 'Error while building the security context';
    const badLoginPasswordError = new Error('Sorry. Logon denied.');
    try {
        const packageInfo = api_1.sspi.QuerySecurityPackageInfo('Negotiate');
        const clientCred = api_1.sspi.AcquireCredentialsHandle({
            packageName: 'Negotiate',
            authData: userCredential,
        });
        const serverCred = api_1.sspi.AcquireCredentialsHandle({
            packageName: 'Negotiate',
        });
        let serverSecurityContext;
        let clientSecurityContext;
        const clientInput = {
            credential: clientCred.credential,
            targetName: 'kiki',
            cbMaxToken: packageInfo.cbMaxToken,
        };
        const serverInput = {
            credential: serverCred.credential,
        };
        let i = 0;
        while (true) {
            debug('i: ', i);
            i++;
            if (serverSecurityContext) {
                clientInput.SecBufferDesc = serverSecurityContext.SecBufferDesc;
                clientInput.contextHandle = clientSecurityContext === null || clientSecurityContext === void 0 ? void 0 : clientSecurityContext.contextHandle;
            }
            clientSecurityContext = api_1.sspi.InitializeSecurityContext(clientInput);
            debug('clientSecurityContext: ', clientSecurityContext);
            debug((0, misc_1.hexDump)(clientSecurityContext.SecBufferDesc.buffers[0]));
            if (clientSecurityContext.SECURITY_STATUS !== 'SEC_I_CONTINUE_NEEDED' &&
                clientSecurityContext.SECURITY_STATUS !== 'SEC_E_OK') {
                throw errorMsg;
            }
            serverInput.SecBufferDesc = clientSecurityContext.SecBufferDesc;
            if (serverSecurityContext) {
                serverInput.contextHandle = serverSecurityContext.contextHandle;
            }
            serverSecurityContext = api_1.sspi.AcceptSecurityContext(serverInput);
            debug('serverSecurityContext: ', serverSecurityContext);
            if (serverSecurityContext.SECURITY_STATUS !== 'SEC_I_CONTINUE_NEEDED' &&
                serverSecurityContext.SECURITY_STATUS !== 'SEC_E_OK') {
                if (serverSecurityContext.SECURITY_STATUS === 'SEC_E_LOGON_DENIED') {
                    throw badLoginPasswordError;
                }
                throw errorMsg;
            }
            debug((0, misc_1.hexDump)(serverSecurityContext.SecBufferDesc.buffers[0]));
            if (serverSecurityContext.SECURITY_STATUS !== 'SEC_E_OK') {
                continue;
            }
            // we have the security context !!!
            debug('We have the security context !!!');
            break;
        }
        const sso = new SSO_1.SSO(serverSecurityContext.contextHandle, undefined);
        await sso.load();
        if (sso.user.name === 'Guest') {
            throw badLoginPasswordError;
        }
        return sso;
    }
    catch (e) {
        if (e === badLoginPasswordError) {
            throw e;
        }
        console.error('error', e);
        throw e;
    }
}
exports.connect = connect;
//# sourceMappingURL=connect.js.map