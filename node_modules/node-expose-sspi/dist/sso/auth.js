"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.auth = void 0;
const http_errors_1 = __importDefault(require("http-errors"));
const debug_1 = __importDefault(require("debug"));
const api_1 = require("../../lib/api");
const misc_1 = require("./misc");
const SSO_1 = require("./SSO");
const ServerContextHandleManager_1 = require("./schm/ServerContextHandleManager");
const status_1 = require("./status");
const kerberos_1 = require("./kerberos");
const DEBUG_KEY = 'node-expose-sspi:auth';
const debug = (0, debug_1.default)(DEBUG_KEY);
const isDbgEnabled = debug_1.default.enabled(DEBUG_KEY);
const WWW_AUTHENTICATE = 'WWW-Authenticate';
const startMessageList = ['NTLM_NEGOTIATE_01', 'Kerberos_1'];
/**
 * Tries to get SSO information from browser. If success, the SSO info
 * is stored under req.sso
 *
 * @export
 * @param {AuthOptions} [options={}]
 * @returns {RequestHandler}
 */
function auth(options = {}) {
    const opts = {
        useActiveDirectory: true,
        useGroups: true,
        useOwner: false,
        groupFilterRegex: '.*',
        allowsGuest: false,
        allowsAnonymousLogon: false,
        useSession: false,
        forceNTLM: false,
        ...options,
    };
    const authenticationType = opts.forceNTLM ? 'NTLM' : 'Negotiate';
    const packageName = 'Negotiate';
    let { credential, tsExpiry } = api_1.sspi.AcquireCredentialsHandle({
        packageName,
    });
    const checkCredentials = () => {
        if (tsExpiry < new Date()) {
            // renew server credentials
            api_1.sspi.FreeCredentialsHandle(credential);
            const renewed = api_1.sspi.AcquireCredentialsHandle({
                packageName,
            });
            credential = renewed.credential;
            tsExpiry = renewed.tsExpiry;
        }
    };
    const schManager = new ServerContextHandleManager_1.ServerContextHandleManager();
    // returns the node middleware.
    return (req, res, next) => {
        if (opts.useSession) {
            const session = req
                .session;
            debug('check the session: ', session);
            if (session === null || session === void 0 ? void 0 : session.sso) {
                session.sso.cached = true;
                req.sso = session.sso;
                next();
                return;
            }
            debug('no session.sso');
        }
        (async () => {
            var _a, _b, _c, _d;
            let messageType = 'Unknown';
            try {
                const authorization = req.headers.authorization;
                if (!authorization) {
                    debug('no authorization key in header');
                    res.statusCode = 401;
                    res.setHeader(WWW_AUTHENTICATE, authenticationType);
                    res.end();
                    return;
                }
                if (!authorization.startsWith(authenticationType + ' ')) {
                    res.statusCode = 400;
                    res.end(`Malformed authentication token: ${authorization}`);
                    return;
                }
                checkCredentials();
                const token = authorization.substring((authenticationType + ' ').length);
                messageType = (0, misc_1.getMessageType)(token);
                debug('messageType: ', messageType);
                const buffer = (0, misc_1.decode)(token);
                debug((0, misc_1.hexDump)(buffer));
                // test if first token
                if (startMessageList.includes(messageType)) {
                    schManager.release(req);
                }
                // kerberos token case
                if (isDbgEnabled && messageType === 'Kerberos_1') {
                    debug('Kerberos_1 details: ', (0, kerberos_1.getKerberosDetails)(buffer));
                }
                const input = {
                    credential,
                    SecBufferDesc: {
                        ulVersion: 0,
                        buffers: [buffer],
                    },
                };
                const serverContextHandle = schManager.get(req);
                if (serverContextHandle) {
                    debug('adding to input a serverContextHandle (not first exchange)');
                    input.contextHandle = serverContextHandle;
                }
                else if (!startMessageList.includes(messageType)) {
                    throw new Error('serverContextHandle not retrieved.');
                }
                debug('input just before calling AcceptSecurityContext', input);
                const serverSecurityContext = api_1.sspi.AcceptSecurityContext(input);
                debug('serverSecurityContext just after AcceptSecurityContext', serverSecurityContext);
                if (isDbgEnabled && messageType.startsWith('Kerberos')) {
                    debug('Kerberos output details: ', (0, kerberos_1.getKerberosResponseDetails)(serverSecurityContext.SecBufferDesc.buffers[0]));
                }
                const failed = !['SEC_E_OK', 'SEC_I_CONTINUE_NEEDED'].includes(serverSecurityContext.SECURITY_STATUS);
                if (failed) {
                    schManager.release(req);
                    // 'SEC_I_COMPLETE_AND_CONTINUE', 'SEC_I_COMPLETE_NEEDED' are considered as errors because it is used
                    // only by 'Digest' SSP. (not by Negotiate, Kerberos or NTLM)
                    if (serverSecurityContext.SECURITY_STATUS === 'SEC_E_LOGON_DENIED') {
                        next((0, http_errors_1.default)(401, `SEC_E_LOGON_DENIED. (incorrect login/password, or account disabled, or locked, etc.). Protocol Message = ${messageType}.`));
                        return;
                    }
                    throw new Error('AcceptSecurityContext error: ' +
                        serverSecurityContext.SECURITY_STATUS);
                }
                schManager.set(req, serverSecurityContext.contextHandle);
                debug('AcceptSecurityContext output buffer');
                debug((0, misc_1.hexDump)(serverSecurityContext.SecBufferDesc.buffers[0]));
                if (serverSecurityContext.SECURITY_STATUS === 'SEC_I_CONTINUE_NEEDED') {
                    res.statusCode = 401;
                    res.setHeader(WWW_AUTHENTICATE, authenticationType +
                        ' ' +
                        (0, misc_1.encode)(serverSecurityContext.SecBufferDesc.buffers[0]));
                    res.end();
                    return;
                }
                const lastServerContextHandle = serverSecurityContext.contextHandle;
                if (!lastServerContextHandle) {
                    throw new Error('cannot get the server context handle');
                }
                const method = messageType.startsWith('NTLM')
                    ? 'NTLM'
                    : 'Kerberos';
                const sso = new SSO_1.SSO(lastServerContextHandle, method);
                sso.setOptions(opts);
                await sso.load();
                req.sso = sso.getJSON();
                if (opts.useSession) {
                    debug('session case');
                    const session = req
                        .session;
                    debug('session: ', session);
                    if (session) {
                        req.sso.cached = false;
                        session.sso = req.sso;
                    }
                    debug('session again: ', session);
                }
                api_1.sspi.DeleteSecurityContext(lastServerContextHandle);
                schManager.release(req);
                // check if user is allowed.
                if (!opts.allowsAnonymousLogon &&
                    ((_b = (_a = req.sso) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.name) === 'ANONYMOUS LOGON') {
                    res.statusCode = 401;
                    res.end('Anonymous login not authorized.');
                    return;
                }
                if (!opts.allowsGuest && ((_d = (_c = req.sso) === null || _c === void 0 ? void 0 : _c.user) === null || _d === void 0 ? void 0 : _d.name) === 'Guest') {
                    res.statusCode = 401;
                    res.end('Guest not authorized.');
                    return;
                }
                // user authenticated and allowed.
                res.setHeader(WWW_AUTHENTICATE, authenticationType +
                    ' ' +
                    (0, misc_1.encode)(serverSecurityContext.SecBufferDesc.buffers[0]));
                return next();
            }
            catch (e) {
                schManager.release(req);
                console.error(e);
                console.error('statusInfo: ', (0, status_1.getStatusInfo)());
                console.error('messageType: ', messageType);
                const message = e instanceof Error ? e.message : e;
                next((0, http_errors_1.default)(401, `Error while doing SSO: ${message}`));
            }
        })();
    };
}
exports.auth = auth;
//# sourceMappingURL=auth.js.map