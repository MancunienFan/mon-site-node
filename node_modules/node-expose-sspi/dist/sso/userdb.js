"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDistinguishedName = exports.getUsers = exports.getUser = exports.init = exports.database = void 0;
const api_1 = require("../../lib/api");
const domain_1 = require("./domain");
const debug_1 = __importDefault(require("debug"));
const mutex_1 = require("./mutex");
const adConnection_1 = require("./adConnection");
const debug = (0, debug_1.default)('node-expose-sspi:userdb');
exports.database = {
    users: [],
};
/**
 *
 * This function is recommanded to be called before starting a server.
 *
 * Purpose is to cache all Active Directory (AD) users for
 * performance during authentication, just for increasing performance.
 *
 * Useless if you do not use AD.
 *
 * @export
 * @returns {Promise<void>}
 */
async function init() {
    if (!(0, domain_1.isOnDomain)()) {
        return;
    }
    try {
        debug('init');
        // request all accounts from domain
        exports.database.users = await getUsers();
    }
    catch (e) {
        debug('Cannot get users from AD. e: ', e);
    }
}
exports.init = init;
async function getUser(ldapFilter) {
    debug('getUser start ');
    if (!(0, domain_1.isOnDomain)()) {
        return;
    }
    if (!(0, domain_1.isActiveDirectoryReachable)()) {
        console.error('Warning: Active Directory not reachable');
        return;
    }
    const adRelease = await mutex_1.activeDirectoryMutex.acquire();
    (0, adConnection_1.openADConnection)();
    let dirsearch;
    try {
        const distinguishedName = await getDistinguishedName();
        dirsearch = await api_1.adsi.ADsOpenObject({
            binding: `LDAP://${distinguishedName}`,
            riid: 'IID_IDirectorySearch',
        });
        dirsearch.SetSearchPreference();
        dirsearch.ExecuteSearch({
            filter: `(&(objectClass=user)(objectCategory=person)${ldapFilter})`,
        });
        const hr = dirsearch.GetNextRow();
        if (hr === api_1.adsi.S_ADS_NOMORE_ROWS) {
            return undefined;
        }
        const row = {};
        let colName = dirsearch.GetNextColumnName();
        while (colName !== api_1.adsi.S_ADS_NOMORE_COLUMNS) {
            const value = await dirsearch.GetColumn(colName);
            row[colName] = value;
            colName = dirsearch.GetNextColumnName();
        }
        return row;
    }
    finally {
        if (dirsearch) {
            dirsearch.Release();
        }
        (0, adConnection_1.closeADConnection)();
        adRelease();
        debug('getUser end');
    }
}
exports.getUser = getUser;
async function getUsers(ldapFilter) {
    debug('getUsers start ');
    if (!(0, domain_1.isOnDomain)()) {
        return [];
    }
    const adRelease = await mutex_1.activeDirectoryMutex.acquire();
    if (!(0, domain_1.isActiveDirectoryReachable)()) {
        console.error('Warning: Active Directory not reachable');
        return [];
    }
    const result = [];
    (0, adConnection_1.openADConnection)();
    let dirsearch;
    try {
        const distinguishedName = await getDistinguishedName();
        dirsearch = await api_1.adsi.ADsOpenObject({
            binding: `LDAP://${distinguishedName}`,
            riid: 'IID_IDirectorySearch',
        });
        dirsearch.SetSearchPreference();
        dirsearch.ExecuteSearch({
            filter: `(&(objectClass=user)(objectCategory=person)(sn=*)${ldapFilter || ''})`,
        });
        while (true) {
            if (dirsearch.GetNextRow() === api_1.adsi.S_ADS_NOMORE_ROWS) {
                break;
            }
            const row = {};
            let colName = dirsearch.GetNextColumnName();
            while (colName !== api_1.adsi.S_ADS_NOMORE_COLUMNS) {
                const value = await dirsearch.GetColumn(colName);
                row[colName] = value;
                colName = dirsearch.GetNextColumnName();
            }
            result.push(row);
        }
    }
    catch (error) {
        console.error('error: ', error);
    }
    finally {
        if (dirsearch) {
            dirsearch.Release();
        }
        (0, adConnection_1.closeADConnection)();
        adRelease();
        debug('getUsers end');
    }
    return result;
}
exports.getUsers = getUsers;
async function getDistinguishedName() {
    let root;
    try {
        root = await api_1.adsi.ADsGestObject('LDAP://rootDSE');
        const distinguishedName = await root.Get('defaultNamingContext');
        return distinguishedName;
    }
    finally {
        if (root) {
            root.Release();
        }
    }
}
exports.getDistinguishedName = getDistinguishedName;
//# sourceMappingURL=userdb.js.map