"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SCHMWithSync = void 0;
const debug_1 = __importDefault(require("debug"));
const ServerContextHandleManager_1 = require("./ServerContextHandleManager");
const debug = debug_1.default('node-expose-sspi:schManager');
const TOO_LATE_ERROR_MSG = 'too many concurrent connections.';
class SCHMWithSync extends ServerContextHandleManager_1.ServerContextHandleManager {
    constructor(delayMax = 20000) {
        super();
        this.delayMax = delayMax;
        /**
         * The queue of other authentication that are waiting.
         *
         * @private
         * @type {AuthItem[]}
         * @memberof SCHMWithSync
         */
        this.queue = [];
    }
    waitForReleased() {
        return new Promise((resolve, reject) => {
            debug('waitForReleased: start promise');
            const timeout = setTimeout(() => {
                this.interrupt();
            }, this.delayMax);
            // if nobody else is currently authenticating then go now.
            if (this.authItem === undefined) {
                debug('waitForReleased: we can start now.');
                this.authItem = { timeout };
                return resolve();
            }
            debug('someone is currently authenticating, go in the queue and wait for your turn.');
            this.queue.push({ resolve, reject, timeout });
            debug('queue length', this.queue.length);
        });
    }
    getMethod() {
        return this.method;
    }
    setMethod(ssoMethod) {
        this.method = ssoMethod;
    }
    getHandle() {
        return this.serverContextHandle;
    }
    setHandle(contextHandle) {
        this.serverContextHandle = contextHandle;
    }
    release() {
        var _a;
        if (this.authItem) {
            clearTimeout(this.authItem.timeout);
        }
        this.serverContextHandle = undefined;
        this.authItem = undefined;
        if (this.queue.length > 0) {
            // it means another client B was waiting for authenticating.
            // so we start authenticating this client B.
            this.authItem = this.queue.shift();
            debug('releasing. queue length', this.queue.length);
            if ((_a = this.authItem) === null || _a === void 0 ? void 0 : _a.resolve) {
                this.authItem.resolve();
            }
        }
    }
    /**
     * after timeout, all the queue is removed and rejected.
     * does not go to its final state before timeout.
     *
     *
     * @param {AuthItem} authItem
     * @returns
     * @memberof ServerContextHandleManager
     */
    interrupt() {
        while (this.queue.length > 0) {
            const ai = this.queue.pop();
            if (ai) {
                clearTimeout(ai.timeout);
                if (ai.reject) {
                    ai.reject(TOO_LATE_ERROR_MSG);
                }
            }
        }
        this.authItem = undefined;
        this.serverContextHandle = undefined;
    }
}
exports.SCHMWithSync = SCHMWithSync;
//# sourceMappingURL=SCHMWithSync.js.map