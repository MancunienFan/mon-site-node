"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerContextHandleManager = void 0;
// 2 minutes
const DELAY = 1000 * 60 * 2;
const getUniqueId = (req) => {
    // Manage the case where we are behind a proxy.
    // Proxy must configure a 'forwarded' header.
    if (req.headers['forwarded']) {
        return req.headers['forwarded'];
    }
    if (req.headers['x-forwarded-for'])
        return [req.headers['x-forwarded-for'], req.headers['connection']].join('_');
    if (req.headers['x-real-ip']) {
        return [req.headers['x-real-ip'], req.headers['connection']].join('_');
    }
    // manage the case where there is no proxy.
    return [req.socket.remoteAddress, req.socket.remotePort].join('_');
};
const getId = (req) => {
    const id = getUniqueId(req);
    return id;
};
class ServerContextHandleManager {
    constructor() {
        this.cache = new Map();
    }
    release(req) {
        this.refresh();
        this.cache.delete(getId(req));
    }
    get(req) {
        var _a;
        this.refresh();
        const handle = (_a = this.cache.get(getId(req))) === null || _a === void 0 ? void 0 : _a.handle;
        return handle;
    }
    set(req, handle) {
        this.refresh();
        const item = this.cache.get(getId(req));
        if (item) {
            item.handle = handle;
            return;
        }
        this.cache.set(getId(req), {
            handle,
            timestamp: new Date().getTime(),
        });
    }
    refresh() {
        for (const [k, v] of [...this.cache.entries()]) {
            if (v.timestamp < new Date().getTime() - DELAY) {
                console.log('delete k', k);
                this.cache.delete(k);
            }
        }
    }
}
exports.ServerContextHandleManager = ServerContextHandleManager;
//# sourceMappingURL=ServerContextHandleManager.js.map