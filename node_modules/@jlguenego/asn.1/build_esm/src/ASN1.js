import { ASN1ModuleFactory } from './asn1/ASN1ModuleFactory';
import { ASN1Generator } from './ASN1Generator';
import { ASN1Validator } from './ASN1Validator';
import { BERDecode } from './codec/ber/decoder/BERDecoder';
import { DEREncode } from './codec/der/encoder/DEREncoder';
import { EncodingRule } from './EncodingRule';
import { ASN1MessageFormat } from './interfaces/ASN1MessageFormat';
import { getArrayBufferFromStr } from './misc';
export class ASN1 {
    static decode(message, opts = {}) {
        const options = {
            format: ASN1MessageFormat.HEX,
            encodingRule: EncodingRule.DER,
            ...opts,
        };
        let input;
        if (typeof message === 'string') {
            input = getArrayBufferFromStr(message, options.format);
        }
        else {
            input = message;
        }
        if ([EncodingRule.BER, EncodingRule.CER, EncodingRule.DER].includes(options.encodingRule)) {
            return BERDecode(input);
        }
        throw new Error('Encoding rule not yet implemented: ' + options.encodingRule);
    }
    static getModuleFromStr(definition) {
        return ASN1ModuleFactory.compile(definition);
    }
    static encode(asn1Message, encodingRule = EncodingRule.DER) {
        if (encodingRule === EncodingRule.DER ||
            encodingRule === EncodingRule.BER) {
            return Buffer.from(DEREncode(asn1Message), 'hex');
        }
        throw new Error('generate: encoding rule not yet implemented: ' + encodingRule);
    }
    static generate(module, type, data, opts = {}) {
        const options = {
            encodingRule: EncodingRule.DER,
            inputFormat: 'json',
            ...opts,
        };
        const generator = new ASN1Generator(module, type);
        const asn1Message = generator.generateFromJson(data);
        return ASN1.encode(asn1Message, options.encodingRule);
    }
    static validate(module, message, type) {
        const msg = JSON.parse(JSON.stringify(message));
        const validator = new ASN1Validator(module);
        validator.validate(msg, type);
        return msg;
    }
}
//# sourceMappingURL=ASN1.js.map