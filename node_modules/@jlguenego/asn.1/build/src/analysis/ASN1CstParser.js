"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASN1CstParser = void 0;
const chevrotain_1 = require("chevrotain");
const ASN1Lexer_1 = require("./ASN1Lexer");
const ASN1Keyword_1 = require("./lexer/ASN1Keyword");
const BuiltinTypeRules_1 = require("./parser/BuiltinTypeRules");
const BuiltinValueRules_1 = require("./parser/BuiltinValueRules");
const ChoiceTypeRules_1 = require("./parser/ChoiceTypeRules");
const ConstrainedTypeRules_1 = require("./parser/ConstrainedTypeRules");
const ImportsRules_1 = require("./parser/ImportsRules");
const IntegerTypeRules_1 = require("./parser/IntegerTypeRules");
const ModuleIdentifierRules_1 = require("./parser/ModuleIdentifierRules");
const ObjectIdentifierValueRules_1 = require("./parser/ObjectIdentifierValueRules");
const ReferencedTypeRules_1 = require("./parser/ReferencedTypeRules");
const SequenceOfTypeRules_1 = require("./parser/SequenceOfTypeRules");
const SequenceTypeRules_1 = require("./parser/SequenceTypeRules");
const SizeConstraintRules_1 = require("./parser/SizeConstraintRules");
const TaggedTypeRules_1 = require("./parser/TaggedTypeRules");
const TypeRules_1 = require("./parser/TypeRules");
class ASN1CstParser extends chevrotain_1.CstParser {
    addOrList(names) {
        const array = names.map(name => ({
            ALT: () => {
                this.SUBRULE(this[name]);
            },
        }));
        this.OR(array);
    }
    addOrTokenList(tokens) {
        const array = tokens.map(t => ({
            ALT: () => {
                this.CONSUME(t);
            },
        }));
        this.OR(array);
    }
    constructor() {
        super(ASN1Lexer_1.allASN1Tokens);
        this.RULE('ModuleDefinition', () => {
            this.SUBRULE(this.ModuleIdentifier);
            this.CONSUME(ASN1Keyword_1.k.DEFINITIONS);
            this.SUBRULE(this.TagDefault);
            this.SUBRULE(this.ExtensionDefault);
            this.CONSUME(ASN1Lexer_1.AFFECTATION);
            this.CONSUME(ASN1Keyword_1.k.BEGIN);
            this.SUBRULE(this.ModuleBody);
            this.CONSUME(ASN1Keyword_1.k.END);
        });
        this.RULE('TagDefault', () => {
            this.OPTION(() => {
                this.addOrTokenList([ASN1Keyword_1.k.EXPLICIT, ASN1Keyword_1.k.IMPLICIT, ASN1Keyword_1.k.AUTOMATIC]);
                this.CONSUME(ASN1Keyword_1.k.TAGS);
            });
        });
        this.RULE('ExtensionDefault', () => {
            this.OPTION(() => {
                this.CONSUME(ASN1Keyword_1.k.EXTENSIBILITY);
                this.CONSUME(ASN1Keyword_1.k.IMPLIED);
            });
        });
        this.RULE('ModuleBody', () => {
            this.SUBRULE(this.Imports);
            this.SUBRULE(this.AssignmentList);
        });
        this.RULE('AssignmentList', () => {
            this.MANY(() => {
                this.SUBRULE(this.Assignment);
            });
        });
        this.RULE('Assignment', () => {
            this.addOrList(['TypeAssignment', 'ValueAssignment']);
        });
        ModuleIdentifierRules_1.initModuleIdentifierRules.call(this);
        BuiltinValueRules_1.initBuiltinValueRules.call(this);
        BuiltinTypeRules_1.initBuiltinTypeRules.call(this);
        ConstrainedTypeRules_1.initConstrainedTypeRules.call(this);
        IntegerTypeRules_1.initIntegerTypeRules.call(this);
        ObjectIdentifierValueRules_1.initObjectIdentifierValueRules.call(this);
        SequenceTypeRules_1.initSequenceTypeRules.call(this);
        SequenceOfTypeRules_1.initSequenceOfTypeRules.call(this);
        TypeRules_1.initTypeRules.call(this);
        ReferencedTypeRules_1.initReferencedTypeRules.call(this);
        TaggedTypeRules_1.initTaggedTypeRules.call(this);
        SizeConstraintRules_1.initSizeConstraintRules.call(this);
        ChoiceTypeRules_1.initChoiceTypeRules.call(this);
        ImportsRules_1.initImportsRules.call(this);
        this.performSelfAnalysis();
    }
}
exports.ASN1CstParser = ASN1CstParser;
//# sourceMappingURL=ASN1CstParser.js.map