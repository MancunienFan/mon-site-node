"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.padHexString = exports.cloneAlpha = exports.formatBitString = exports.getArrayBufferFromStr = exports.sanitize = void 0;
const sanitize = (str) => str
    .replace(/#.*/g, '')
    .replace(/ /g, '')
    .replace(/\r?\n|\r/g, '');
exports.sanitize = sanitize;
const getArrayBufferFromStr = (inputMsg, format) => {
    if (format === 'hex') {
        const buf = Buffer.from((0, exports.sanitize)(inputMsg), 'hex');
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    if (format === 'base64') {
        const buf = Buffer.from((0, exports.sanitize)(inputMsg), 'base64');
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    throw new Error('format not yet implemented: ' + format);
};
exports.getArrayBufferFromStr = getArrayBufferFromStr;
// 0110011001010 -> 0_1100_1100_1010
function formatBitString(value) {
    const bits = value.split('');
    let result = '';
    for (let i = 0; i < bits.length; i++) {
        const bit = bits[bits.length - 1 - i];
        const sep = i === 0 || i % 4 ? '' : '_';
        result = bit + sep + result;
    }
    return result;
}
exports.formatBitString = formatBitString;
function cloneAlpha(obj) {
    const x = {};
    for (const key of Object.keys(obj).sort()) {
        if (obj[key] instanceof Array) {
            x[key] = obj[key].map(k => cloneAlpha(k));
        }
        else if (obj[key] instanceof Object) {
            x[key] = cloneAlpha(obj[key]);
        }
        else {
            x[key] = obj[key];
        }
    }
    return x;
}
exports.cloneAlpha = cloneAlpha;
function padHexString(hex) {
    if (hex.length % 2) {
        return '0' + hex;
    }
    return hex;
}
exports.padHexString = padHexString;
//# sourceMappingURL=misc.js.map