"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASN1Validator = void 0;
const ASN1DefinedType_1 = require("./asn1/ASN1DefinedType");
const ASN1NamedType_1 = require("./asn1/ASN1NamedType");
const ASN1Sequence_1 = require("./asn1/ASN1Sequence");
const ASN1TaggedType_1 = require("./asn1/ASN1TaggedType");
const ASN1ChoiceType_1 = require("./asn1/ASN1ChoiceType");
class ASN1Validator {
    constructor(module) {
        this.module = module;
    }
    validate(input, type) {
        const assignment = this.module.getAssignment(type);
        this.validateAssignment(input, assignment);
        input.tagDefinedType = assignment.name;
    }
    validateAssignment(input, assignment) {
        if (assignment.type instanceof ASN1TaggedType_1.ASN1TaggedType) {
            this.validateTaggedType(assignment.type, input);
        }
        if (assignment.type instanceof ASN1Sequence_1.ASN1Sequence) {
            this.validateSequence(assignment.type, input);
        }
    }
    validateTaggedType(taggedType, input) {
        if (input.tagClass !== taggedType.tag.tagClass) {
            throw new Error(`taggedType tagClass differ: ${input.tagClass} vs ${taggedType.tag.tagClass}`);
        }
        if (input.tagCode !== taggedType.tag.tagCode) {
            throw new Error(`taggedType tagCode differ: ${input.tagCode} vs ${taggedType.tag.tagCode}`);
        }
        if (taggedType.type instanceof ASN1Sequence_1.ASN1Sequence) {
            const subInput = taggedType.implicit
                ? input
                : input.value[0];
            this.validateSequence(taggedType.type, subInput);
        }
        if (taggedType.type instanceof ASN1DefinedType_1.ASN1DefinedType) {
            this.validateDefinedType(taggedType.type, input);
        }
    }
    validateSequence(sequence, input) {
        let c = 0;
        for (let i = 0; i < sequence.components.length; i++) {
            const component = sequence.components[i];
            if (!(component instanceof ASN1NamedType_1.ASN1NamedType)) {
                throw new Error('limitation: cannot process only NamedType.');
            }
            // manage optional case
            if (component.optional) {
                try {
                    this.validateComponent(sequence.components[i], input.value[c]);
                }
                catch (e) {
                    continue;
                }
            }
            this.validateComponent(sequence.components[i], input.value[c]);
            c++;
        }
    }
    validateComponent(component, input) {
        if (!(component instanceof ASN1NamedType_1.ASN1NamedType)) {
            throw new Error('can process only ASN1NamedType');
        }
        if (component.type instanceof ASN1ChoiceType_1.ASN1ChoiceType) {
            this.validateChoiceType(component.type, input);
        }
        else if (component.type instanceof ASN1TaggedType_1.ASN1TaggedType) {
            this.validateTaggedType(component.type, input);
        }
        else if (component.type instanceof ASN1DefinedType_1.ASN1DefinedType) {
            input.tagDefinedType = component.type.name;
            const assignment = this.module.getAssignment(component.type.name);
            this.validateAssignment(input, assignment);
        }
        else {
            if (input.value !== null) {
                const name = component.type.constructor.name;
                switch (name) {
                    case 'ASN1BooleanType':
                        if (typeof input.value !== 'boolean') {
                            throw new Error('must be an boolean');
                        }
                        break;
                    case 'ASN1IntegerType':
                        if (!Number.isInteger(input.value)) {
                            throw new Error('must be an integer');
                        }
                        break;
                    case 'ASN1IA5StringType':
                        if (typeof input.value !== 'string') {
                            throw new Error(`must be an string: ${input}`);
                        }
                        break;
                    default:
                        break;
                }
            }
        }
        input.tagName = component.name;
    }
    validateDefinedType(type, input) {
        input.tagDefinedType = type.name;
        const assignment = this.module.getAssignment(type.name);
        this.validateAssignment(input.value[0], assignment);
    }
    validateChoiceType(type, input) {
        // try to validate the first choice, if not ok, then the second, if not ok, then the third...
        for (let i = 0; i < type.alternatives.length; i++) {
            try {
                this.validateComponent(type.alternatives[i], input);
            }
            catch (e) {
                continue;
            }
            break;
        }
    }
}
exports.ASN1Validator = ASN1Validator;
//# sourceMappingURL=ASN1Validator.js.map