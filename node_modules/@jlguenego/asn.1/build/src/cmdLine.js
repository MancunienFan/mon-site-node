"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.asn1Parse = void 0;
const commander_1 = require("commander");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const package_json_1 = require("../package.json");
const ASN1_1 = require("./ASN1");
const misc_1 = require("./misc");
function asn1Parse() {
    commander_1.program
        .version(package_json_1.version)
        .arguments('<msgFile>')
        .option('-d, --definition <asn1-file>', 'specify an ASN.1 definition file (.asn1)')
        .option('-t, --type <asn1-type>', 'specify an ASN.1 type. Must be specified with definition file.')
        .option('-f, --format <type>', "specify the message format ('binary'|'hex'|'base64')", 'hex')
        .description('Parse an ASN1 message', {
        msgFile: 'file containing a ASN.1 message to parse',
    });
    commander_1.program.parse(process.argv);
    if (commander_1.program.args.length === 0) {
        console.log('<msgFile> must be a file specified.');
        commander_1.program.help();
    }
    const file = path_1.default.resolve(process.cwd(), commander_1.program.args[0]);
    let input;
    try {
        if (commander_1.program['format'] === 'binary') {
            const b = fs_1.default.readFileSync(file);
            input = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
        }
        else if (commander_1.program['format'] === 'hex') {
            const str = fs_1.default.readFileSync(file, { encoding: 'utf8' });
            const b = Buffer.from((0, misc_1.sanitize)(str), 'hex');
            input = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
        }
        else if (commander_1.program['format'] === 'base64') {
            const str = fs_1.default.readFileSync(file, { encoding: 'utf8' });
            const b = Buffer.from((0, misc_1.sanitize)(str), 'base64');
            input = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
        }
        else {
            throw new Error(`Cannot understand the format. (${commander_1.program['format']}. Value accepted: bin|hex|base64)`);
        }
    }
    catch (e) {
        if (e instanceof Error) {
            console.log('Cannot read <msgFile>:', e.message);
        }
        commander_1.program.help();
    }
    let asn1Definition;
    try {
        if (commander_1.program['definition']) {
            const asn1File = path_1.default.resolve(process.cwd(), commander_1.program['definition']);
            asn1Definition = fs_1.default.readFileSync(asn1File, { encoding: 'utf8' });
        }
        else {
            asn1Definition = undefined;
        }
    }
    catch (e) {
        if (e instanceof Error) {
            console.log('Cannot read <asn1-file>:', e.message);
        }
        commander_1.program.help();
    }
    let output = ASN1_1.ASN1.decode(input);
    if (asn1Definition) {
        if (!commander_1.program.type) {
            console.log('When --definition is specified, --type must be too.');
            commander_1.program.help();
        }
        const module = ASN1_1.ASN1.getModuleFromStr(asn1Definition);
        output = ASN1_1.ASN1.validate(module, output, commander_1.program.type);
    }
    console.log((0, util_1.inspect)((0, misc_1.cloneAlpha)(output), false, null, true));
}
exports.asn1Parse = asn1Parse;
//# sourceMappingURL=cmdLine.js.map