"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NTLMType2Parser = void 0;
// import dbg from 'debug';
const AbstractParser_1 = require("./AbstractParser");
const ntlm_utils_1 = require("../ntlm/ntlm-utils");
const misc_1 = require("../misc");
const interfaces_1 = require("../ntlm/interfaces");
const flags_1 = require("../ntlm/flags");
// const debug = dbg('node-expose-sspi:ntlm-parser');
class NTLMType2Parser extends AbstractParser_1.AbstractParser {
    constructor(buffer) {
        super(buffer);
    }
    parse() {
        const targetNameSecBuf = ntlm_utils_1.getSecBuf(this.buffer, 12);
        const flag = new Uint32Array(this.buffer.slice(20, 24))[0];
        const result = {
            messageType: interfaces_1.NTLMMessageType.CHALLENGE_MESSAGE,
            targetNameSecBuf,
            flags: misc_1.getFlags(flags_1.ntlmFlags, flag),
            challenge: Buffer.from(this.buffer.slice(24, 32)).toString('hex'),
            targetNameData: ntlm_utils_1.getSecBufData(this.buffer, targetNameSecBuf, ntlm_utils_1.getNtlmEncoding(flag)),
        };
        if (targetNameSecBuf.offset !== 32) {
            // NTLM v2
            result.context = Buffer.from(this.buffer.slice(32, 40)).toString('hex');
            result.targetInfoSecBuf = ntlm_utils_1.getSecBuf(this.buffer, 40);
            result.targetInfoData = ntlm_utils_1.getTargetInfo(this.buffer, result.targetInfoSecBuf);
        }
        if (targetNameSecBuf.offset !== 48) {
            // NTLM version 3: OS Version structure.
            result.osVersionStructure = ntlm_utils_1.getOSVersionStructure(this.buffer, 48);
        }
        return result;
    }
}
exports.NTLMType2Parser = NTLMType2Parser;
//# sourceMappingURL=NTLMType2Parser.js.map