"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NTLMType1Parser = void 0;
// import dbg from 'debug';
const AbstractParser_1 = require("./AbstractParser");
const ntlm_utils_1 = require("../ntlm/ntlm-utils");
const misc_1 = require("../misc");
const interfaces_1 = require("../ntlm/interfaces");
const flags_1 = require("../ntlm/flags");
// const debug = dbg('node-expose-sspi:ntlm-parser');
class NTLMType1Parser extends AbstractParser_1.AbstractParser {
    constructor(buffer) {
        super(buffer);
    }
    parse() {
        const flag = new Uint32Array(this.buffer.slice(12, 16))[0];
        const result = {
            messageType: interfaces_1.NTLMMessageType.NEGOTIATE_MESSAGE,
            flags: misc_1.getFlags(flags_1.ntlmFlags, flag),
        };
        if (this.buffer.byteLength === 16) {
            // NTLM version 1.
            return result;
        }
        result.suppliedDomain = ntlm_utils_1.getSecBuf(this.buffer, 16);
        result.suppliedWorkstation = ntlm_utils_1.getSecBuf(this.buffer, 24);
        if (result.suppliedDomain.offset !== 32) {
            // NTLM version 3: OS Version structure.
            result.osVersionStructure = ntlm_utils_1.getOSVersionStructure(this.buffer, 32);
        }
        result.suppliedDomainData = ntlm_utils_1.getSecBufData(this.buffer, result.suppliedDomain, 'ascii');
        result.suppliedWorkstationData = ntlm_utils_1.getSecBufData(this.buffer, result.suppliedWorkstation, 'ascii');
        return result;
    }
}
exports.NTLMType1Parser = NTLMType1Parser;
//# sourceMappingURL=NTLMType1Parser.js.map